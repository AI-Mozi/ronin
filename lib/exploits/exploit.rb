#
# Ronin - A decentralized repository for the storage and sharing of computer
# security advisories, exploits and payloads.
#
# Copyright (c) 2007 Hal Brodigan (postmodern at users.sourceforge.net)
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#

require 'advisory'
require 'parameters'
require 'exceptions/exploitnotbuilt'

module Ronin
  class Exploit

    include Parameters

    # Vulnerability information
    attr_accessor :advisory

    # Name of the specific exploit
    attr_accessor :name

    # Version of the exploit
    attr_accessor :version

    # Authors of the exploit
    attr_accessor :authors

    # Exploit output
    attr_reader :data

    # Restricted pattern that may not occurr in the exploit output
    attr_accessor :restricted

    # Padding parameter
    attr_param :pad

    # Payload parameter
    attr_param :payload

    def initialize(advisory=nil,&block)
      @advisory = advisory
      @name = ""
      @version = ""
      @authors = {}
      @data = ""

      param_set(:pad,'padding string','A')
      param_set(:payload,'payload')

      block.call(self) if block
    end

    def pad_buffer(pad_str,length)
      buffer = pad_str*(length/pad_str.length)

      pad_remaining = (length % pad_str.length)
      buffer+=pad_str[0,pad_remaining] unless pad_remaining==0

      return buffer
    end

    def restrict(pattern)
      if @restricted
        @restricted = @restricted.union(pattern)
      else
	@restricted = pattern
      end
    end

    def builder(&block)
      @build_block = block
    end

    def is_built?
      !(@data.empty?)
    end

    def build
      @data = ""

      @build_block.call(self) if @build_block

      if (@data && @restricted)
        if @restricted =~ @data
          raise RestrictedText, "Restricted text was found in the exploit output", caller
	end
      end

      return @data
    end

    def cleaner(&block)
      @clean_block = block
    end

    def is_clean?
      @data.empty?
    end

    def clean
      @clean_block.call(self) if @clean_block

      @data = ""
    end

    def transmitter(&block)
      @transmit_block = block
    end

    def transmit
      unless @data.length
	raise ExploitNotBuilt, "cannot transmit unbuilt exploit", caller
      end

      return @transmit_block.call(self) if @transmit_block
    end

    def to_s
      @data
    end

  end
end
